<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>taoensso.tufte documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Tufte</span> <span class="project-version">2.0.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>taoensso</span></div></div></li><li class="depth-2 current"><a href="taoensso.tufte.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tufte</span></div></a></li><li class="depth-3 branch"><a href="taoensso.tufte.examples.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>examples</span></div></a></li><li class="depth-3 branch"><a href="taoensso.tufte.impl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></a></li><li class="depth-3 branch"><a href="taoensso.tufte.stats.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>stats</span></div></a></li><li class="depth-3"><a href="taoensso.tufte.timbre.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timbre</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.tufte.html#var-*min-level*"><div class="inner"><span>*min-level*</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-*ns-filter*"><div class="inner"><span>*ns-filter*</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var--compile-ns-filter"><div class="inner"><span>-compile-ns-filter</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var--elide.3F"><div class="inner"><span>-elide?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-accumulate-stats"><div class="inner"><span>accumulate-stats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-add-basic-println-handler.21"><div class="inner"><span>add-basic-println-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-add-handler.21"><div class="inner"><span>add-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-capture-time.21"><div class="inner"><span>capture-time!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-chance"><div class="inner"><span>chance</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-compile-ns-filter"><div class="inner"><span>compile-ns-filter</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-defnp"><div class="inner"><span>defnp</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-fnp"><div class="inner"><span>fnp</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-format-pstats"><div class="inner"><span>format-pstats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-handlers_"><div class="inner"><span>handlers_</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-may-profile.3F"><div class="inner"><span>may-profile?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-merge-pstats"><div class="inner"><span>merge-pstats</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-new-pdata"><div class="inner"><span>new-pdata</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-p"><div class="inner"><span>p</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-profile"><div class="inner"><span>profile</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-profiled"><div class="inner"><span>profiled</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-profiling.3F"><div class="inner"><span>profiling?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-pspy"><div class="inner"><span>pspy</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-refer-tufte"><div class="inner"><span>refer-tufte</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-remove-handler.21"><div class="inner"><span>remove-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-set-min-level.21"><div class="inner"><span>set-min-level!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-set-ns-pattern.21"><div class="inner"><span>set-ns-pattern!</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-stats-accumulator"><div class="inner"><span>stats-accumulator</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-valid-min-level"><div class="inner"><span>valid-min-level</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-valid-min-level.3F"><div class="inner"><span>valid-min-level?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-valid-run-level"><div class="inner"><span>valid-run-level</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-valid-run-level.3F"><div class="inner"><span>valid-run-level?</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-with-min-level"><div class="inner"><span>with-min-level</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-with-ns-pattern"><div class="inner"><span>with-ns-pattern</span></div></a></li><li class="depth-1"><a href="taoensso.tufte.html#var-with-profiling"><div class="inner"><span>with-profiling</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.tufte</h1><div class="doc"><pre class="plaintext">A simple, fast, monitoring profiler for Clojure/Script.

Usage: wrap+name interesting body exprs with the `p` macro. Then activate
profiling of these wrapped exprs using the `profiled` or `profile` macros:

  (profiled {} (p :my-fn (my-fn))) ; Returns [&lt;body-result&gt; &lt;?pstats&gt;]
  (profile  {} (p :my-fn (my-fn))) ; Returns  &lt;body-result&gt;, dispatches
                                   ; ?pstats to any registered handlers.

Extensive facilities are provided for compile-time elision and runtime
filtering.

See the relevant docstrings for more info:
  `p`, `profiled`, `profile`, `add-handler!` ; Core API

  (p        [opts &amp; body] [id &amp; body]) ; e.g. `(p ::my-pid (do-work))`
  (profiled [opts &amp; body])             ; e.g. `(profiled {:level 2} (my-fn))`
  (profile  [opts &amp; body])             ; e.g. `(profiled {:level 2} (my-fn))`

  (add-handler! [handler-id ns-pattern handler-fn])

How/where to use this library:
  Tufte profiling is highly optimized: even without elision, you can usually
  leave profiling enabled in production (e.g. for sampled profiling, or to
  detect unusual performance behaviour). Tufte's stats maps are well suited
  to programmatic monitoring.</pre></div><div class="public anchor" id="var-*min-level*"><h3>*min-level*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">e/o #{0 1 2 3 4 5 6}
</pre></div></div><div class="public anchor" id="var-*ns-filter*"><h3>*ns-filter*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">(fn [?ns] -&gt; truthy).
</pre></div></div><div class="public anchor" id="var--compile-ns-filter"><h3>-compile-ns-filter</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var--elide.3F"><h3>-elide?</h3><div class="usage"><code>(-elide? level-form ns-str-form)</code></div><div class="doc"><pre class="plaintext">Returns true iff level or ns are compile-time filtered.
</pre></div></div><div class="public anchor" id="var-accumulate-stats"><h3>accumulate-stats</h3><div class="usage"><code>(accumulate-stats stats-accumulator [result ?pstats])</code></div><div class="doc"><pre class="plaintext">Experimental, subject to change!
</pre></div></div><div class="public anchor" id="var-add-basic-println-handler.21"><h3>add-basic-println-handler!</h3><div class="usage"><code>(add-basic-println-handler! {:keys [ns-pattern], :or {ns-pattern "*"}})</code></div><div class="doc"><pre class="plaintext">Adds a simple handler that logs `profile` stats output with `println`.
</pre></div></div><div class="public anchor" id="var-add-handler.21"><h3>add-handler!</h3><div class="usage"><code>(add-handler! handler-id handler-fn)</code><code>(add-handler! handler-id ns-pattern handler-fn)</code></div><div class="doc"><pre class="plaintext">Use this to register interest in stats output produced by `profile` calls.
Each registered `handler-fn` will be called as:

  (handler-fn {:ns-str _ :level _ :?id _ :?data _ :pstats _ :pstats-str_ _})

Map args:
  :ns-str      - Namespace string where `profile` call took place
  :level       - Level e/o #{0 1 2 3 4 5}, given in `(profile {:level _} ...)`
  :?id         - Optional id,              given in `(profile {:id    _} ...)`
  :?data       - Optional arb data,        given in `(profile {:data  _} ...)`
  :pstats      - As in `(second (profiled ...))`. Derefable, mergeable.
  :pstats-str_ - `(delay (format-pstats pstats))

Error handling (NB):
  Handler errors will be silently swallowed. Please `try`/`catch` and
  appropriately deal with (e.g. log) possible errors *within* `handler-fn`.

Async/blocking:
  `handler-fn` should ideally be non-blocking, or reasonably cheap. Handler
   dispatch occurs through a 1-thread 1k-buffer dropping queue.

Ns filtering:
  Provide an optional `ns-pattern` arg to only call handler for matching
  namespaces. See `compile-ns-filter` docstring for details on `ns-pattern`.

Handler ideas:
  Save to a db, log, `put!` to an appropriate `core.async` channel, filter,
  aggregate, use for a realtime analytics dashboard, examine for outliers
  or unexpected output, ...</pre></div></div><div class="public anchor" id="var-capture-time.21"><h3>capture-time!</h3><div class="usage"><code>(capture-time! pdata id nano-secs-elapsed)</code><code>(capture-time! id nano-secs-elapsed)</code></div><div class="doc"><pre class="plaintext">Note: this is a low-level primitive for advanced users!
Can be useful when tracking time across arbitrary thread boundaries or for
async jobs / callbacks / etc.

See `new-pdata` for more info on low-level primitives.</pre></div></div><div class="public anchor" id="var-chance"><h3>chance</h3><div class="usage"><code>(chance p)</code></div><div class="doc"><pre class="plaintext">Returns true with 0&lt;`p`&lt;1 probability.
</pre></div></div><div class="public anchor" id="var-compile-ns-filter"><h3>compile-ns-filter</h3><div class="usage"><code>(compile-ns-filter ns-pattern)</code></div><div class="doc"><pre class="plaintext">Returns (fn [?ns]) -&gt; truthy. Some example patterns:
"foo.bar", "foo.bar.*", #{"foo" "bar"},
{:whitelist ["foo.bar.*"] :blacklist ["baz.*"]}</pre></div></div><div class="public anchor" id="var-defnp"><h3>defnp</h3><h4 class="type">macro</h4><div class="usage"><code>(defnp name doc-string? attr-map? [params*] prepost-map? body)</code><code>(defnp name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?)</code></div><div class="doc"><pre class="plaintext">Like `defn` but wraps fn bodies with `p` macro.
</pre></div></div><div class="public anchor" id="var-fnp"><h3>fnp</h3><h4 class="type">macro</h4><div class="usage"><code>(fnp name? [params*] prepost-map? body)</code><code>(fnp name? ([params*] prepost-map? body) +)</code></div><div class="doc"><pre class="plaintext">Like `fn` but wraps fn bodies with `p` macro.
</pre></div></div><div class="public anchor" id="var-format-pstats"><h3>format-pstats</h3><div class="usage"><code>(format-pstats ps)</code></div><div class="doc"><pre class="plaintext">Formats given pstats to a string table.
Accounted &lt; Clock =&gt; Some work was done that wasn't tracked by any p forms.
Accounted &gt; Clock =&gt; Nested p forms, and/or parallel threads.</pre></div></div><div class="public anchor" id="var-handlers_"><h3>handlers_</h3><div class="usage"></div><div class="doc"><pre class="plaintext">{&lt;handler-id&gt; &lt;handler-fn&gt;}
</pre></div></div><div class="public anchor" id="var-may-profile.3F"><h3>may-profile?</h3><div class="usage"><code>(may-profile? level)</code><code>(may-profile? level ns)</code></div><div class="doc"><pre class="plaintext">Returns true iff level and ns are runtime unfiltered.
</pre></div></div><div class="public anchor" id="var-merge-pstats"><h3>merge-pstats</h3><div class="usage"><code>(merge-pstats)</code><code>(merge-pstats ps0)</code><code>(merge-pstats ps0 ps1)</code></div><div class="doc"><pre class="plaintext">Lossless unless data to merge are very large.
</pre></div></div><div class="public anchor" id="var-new-pdata"><h3>new-pdata</h3><div class="usage"><code>(new-pdata)</code><code>(new-pdata {:keys [dynamic? nmax], :or {dynamic? true, nmax default-nmax}})</code></div><div class="doc"><pre class="plaintext">Note: this is a low-level primitive for advanced users!
Returns a new pdata object for use with `with-profiling` and/or `capture-time!`.
Deref to get pstats:

  (let [pd (new-pdata)
        t0 (System/nanoTime)]
    (with-profiling pd {}
      (p :foo (Thread/sleep 100))
      (capture-time! pd :bar (- t0 (System/nanoTime))))
    @pd)

Dynamic (thread-safe) by default.
*WARNING*: don't change this default unless you're very sure the resulting
pdata object will not be concurrently modified across threads. Concurrent
modification will lead to bad data and/or exceptions!</pre></div></div><div class="public anchor" id="var-p"><h3>p</h3><h4 class="type">macro</h4><div class="usage"><code>(p id &amp; body)</code><code>(p opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Profiling spy. Always executes body, and always returns &lt;body-result&gt;.

When [ns level] unelided and profiling is active, records execution
time of body.

Compile-time opts:
 :id    - Id for this body in stats output (e.g. `::my-fn-call`)
 :level - e/o #{0 1 2 3 4 5} ; Default is `5`</pre></div></div><div class="public anchor" id="var-profile"><h3>profile</h3><h4 class="type">macro</h4><div class="usage"><code>(profile opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Always executes body, and always returns &lt;body-result&gt;.

When [ns level] unelided and [ns level `when`] unfiltered, executes body
with profiling active and dispatches stats to any registered handlers
(see `add-handler!`).

Handy if you'd like to consume/aggregate stats output later/elsewhere.
Otherwise see `profiled`.

Compile-time opts:
  :level    - e/o #{0 1 2 3 4 5} ; Default is `5`
  :dynamic? - Use multi-threaded profiling? ; Default is `false`
  :nmax     - ~Max captures per id before compaction ; Default is 8e5
  :when     - Optional arbitrary conditional form (e.g. boolean expr)
  :id       - Optional stats id provided to handlers (e.g. `::my-stats-1`)
  :data     - Optional arbitrary data provided to handlers

Note on laziness:
  Please note that lazy seqs and other forms of laziness (e.g. delays)
  will only contribute to profiling results if/when evaluation actually
  occurs. This is intentional and a useful property. Compare:

  (profiled {}  (delay (Thread/sleep 2000))) ; Doesn't count sleep
  (profiled {} @(delay (Thread/sleep 2000))) ; Does count sleep</pre></div></div><div class="public anchor" id="var-profiled"><h3>profiled</h3><h4 class="type">macro</h4><div class="usage"><code>(profiled opts &amp; body)</code></div><div class="doc"><pre class="plaintext">Always executes body, and always returns [&lt;body-result&gt; &lt;?pstats&gt;].

When [ns level] unelided and [ns level `when`] unfiltered, executes body
with profiling active.

Handy if you'd like to consume stats output directly.
Otherwise see `profile`.

`pstats` objects are derefable and mergeable:
  - @pstats                 -&gt; {:stats {:n _ :min _ ...} :clock {:t0 _ :t1 _ :total _}}
  - @(merge-pstats ps1 ps2) -&gt; {:stats {:n _ :min _ ...} :clock {:t0 _ :t1 _ :total _}}

Full set of `:stats` keys:
  :n :min :max :mean :mad :sum :p50 :p90 :p95 :p99

Compile-time opts:
  :level    - e/o #{0 1 2 3 4 5} ; Default is `5`
  :dynamic? - Use multi-threaded profiling? ; Default is `false`
  :nmax     - ~Max captures per id before compaction ; Default is 8e5
  :when     - Optional arbitrary conditional form (e.g. boolean expr)

Note on laziness:
  Please note that lazy seqs and other forms of laziness (e.g. delays)
  will only contribute to profiling results if/when evaluation actually
  occurs. This is intentional and a useful property. Compare:

  (profiled {}  (delay (Thread/sleep 2000))) ; Doesn't count sleep
  (profiled {} @(delay (Thread/sleep 2000))) ; Does counts sleep</pre></div></div><div class="public anchor" id="var-profiling.3F"><h3>profiling?</h3><div class="usage"><code>(profiling?)</code></div><div class="doc"><pre class="plaintext">Returns e/o #{nil :thread :dynamic}.
</pre></div></div><div class="public anchor" id="var-pspy"><h3>pspy</h3><h4 class="type">macro</h4><div class="usage"><code>(pspy &amp; args)</code></div><div class="doc"><pre class="plaintext">`p` alias
</pre></div></div><div class="public anchor" id="var-refer-tufte"><h3>refer-tufte</h3><div class="usage"><code>(refer-tufte)</code></div><div class="doc"><pre class="plaintext">(require '[taoensso.tufte :as tufte :refer [defnp p profiled profile]])
</pre></div></div><div class="public anchor" id="var-remove-handler.21"><h3>remove-handler!</h3><div class="usage"><code>(remove-handler! handler-id)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-min-level.21"><h3>set-min-level!</h3><div class="usage"><code>(set-min-level! level)</code></div><div class="doc"><pre class="plaintext">Sets root binding of minimum profiling level, e/o #{0 1 2 3 4 5 6}.
0 =&gt; Enable  all profiling.
6 =&gt; Disable all profiling.</pre></div></div><div class="public anchor" id="var-set-ns-pattern.21"><h3>set-ns-pattern!</h3><div class="usage"><code>(set-ns-pattern! ns-pattern)</code></div><div class="doc"><pre class="plaintext">Sets root binding of namespace filter.
See `compile-ns-filter` docstring for details on `ns-pattern` arg.</pre></div></div><div class="public anchor" id="var-stats-accumulator"><h3>stats-accumulator</h3><div class="usage"><code>(stats-accumulator init-pstats)</code><code>(stats-accumulator)</code></div><div class="doc"><pre class="plaintext">Experimental, subject to change!
Small util to help collect (merge) pstats from multiple runs or threads.

Returns a stateful StatsAccumulator, `acc`:
  - `@acc`           ; Returns current pstats
  - `(acc &lt;pstats&gt;)` ; Synchronously merges given pstats into accumulator

Note that you may want some kind of async/buffer/serialization mechanism in
front of merge calls (e.g. an agent).</pre></div></div><div class="public anchor" id="var-valid-min-level"><h3>valid-min-level</h3><div class="usage"><code>(valid-min-level x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-valid-min-level.3F"><h3>valid-min-level?</h3><div class="usage"><code>(valid-min-level? x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-valid-run-level"><h3>valid-run-level</h3><div class="usage"><code>(valid-run-level x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-valid-run-level.3F"><h3>valid-run-level?</h3><div class="usage"><code>(valid-run-level? x)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-with-min-level"><h3>with-min-level</h3><h4 class="type">macro</h4><div class="usage"><code>(with-min-level level &amp; body)</code></div><div class="doc"><pre class="plaintext">Executes body with dynamic minimum profiling level, e/o #{0 1 2 3 4 5 6}.
0 =&gt; Enable  all profiling.
6 =&gt; Disable all profiling.</pre></div></div><div class="public anchor" id="var-with-ns-pattern"><h3>with-ns-pattern</h3><h4 class="type">macro</h4><div class="usage"><code>(with-ns-pattern ns-pattern &amp; body)</code></div><div class="doc"><pre class="plaintext">Executes body with dynamic namespace filter.
See `compile-ns-filter` docstring for details on `ns-pattern` arg.</pre></div></div><div class="public anchor" id="var-with-profiling"><h3>with-profiling</h3><h4 class="type">macro</h4><div class="usage"><code>(with-profiling pdata {:keys [dynamic? nmax], :or {nmax default-nmax}} &amp; body)</code></div><div class="doc"><pre class="plaintext">Note: this is a low-level primitive for advanced users!
Enables `p` forms in body and returns body's result.

See `new-pdata` for more info on low-level primitives.</pre></div></div></div></body></html>